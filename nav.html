<!DOCTYPE html>
<html>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <style>.wrapper {
    position: absolute;
    width:100%;
    
    top: 0px; left: 0px;
}
.backgroundMap {
   
    position: absolute;top:0px;left:0px;
    max-width:100%;
    z-index: 1;
}
.toOverlay {

    position: absolute;top:0px;left:0px;
    
    background-color: transparent;
    z-index: 2;
    
}</style
    <h1>OLY NAV</h1>
    
    
        <div class="outsideWrapper">
            <div class="wrapper">
                <img id="map"class="backgroundMap" src="https://colin9012.github.io/map.PNG">
                <canvas class="toOverlay" id="canvas" width="800px" height="800px" onmousedown="mousePressed(event)"></canvas>
                <button style="position:absolute;z-index: 3" onclick="window.location.href='index.html'">Go back</button>
            
            </div>
        </div>
    
        
    <script>const nodes = new Map();const floorNodes = new Map();const neighbors = new Map();const roomToNode = new Map();</script>
    <script>
roomToNode.set(148,"a0");
roomToNode.set(149,"a0");
roomToNode.set(150,"a0");
roomToNode.set(152,"a0");
roomToNode.set(153,"a1");
roomToNode.set(156,"a1");
roomToNode.set(155,"a1");
roomToNode.set(157,"a1");
roomToNode.set(158,"a1");
roomToNode.set(150,"a1");
roomToNode.set(147,"a2");
roomToNode.set(145,"a2");
roomToNode.set(142,"a3");
roomToNode.set(161,"a3");
roomToNode.set(134,"a3");
roomToNode.set(135,"a3");
roomToNode.set(133,"a3");
roomToNode.set(144,"a3");
roomToNode.set(124,"a4");
roomToNode.set(122,"a4");
roomToNode.set(123,"a4");
roomToNode.set(121,"a4");
roomToNode.set(125,"a5");
roomToNode.set(127,"a5");
roomToNode.set(128,"a5");
roomToNode.set(129,"a5");
roomToNode.set(130,"a6");
roomToNode.set(131,"a6");
roomToNode.set(102,"a6");
roomToNode.set(101,"a6");
roomToNode.set(118,"a7");
roomToNode.set(119,"a7");
roomToNode.set(117,"a7");
roomToNode.set(116,"a7");
roomToNode.set(115,"a8");
roomToNode.set(114,"a8");
roomToNode.set(112,"a8");
roomToNode.set(110,"a8");
roomToNode.set(111,"a8");
roomToNode.set(107,"a9");
roomToNode.set(103,"a9");
roomToNode.set(105,"a9");
roomToNode.set("Main Office","a10");
roomToNode.set(189,"a11");
// a12 doesn't have any room its just a passover node
roomToNode.set(180,"a13");
roomToNode.set(181,"a13");
roomToNode.set(100,"a14");
roomToNode.set(132,"a14");
roomToNode.set(126,"a14");
roomToNode.set(138,"a15");
roomToNode.set(136,"a15");
roomToNode.set(137,"a15");
roomToNode.set(141,"a15");
// a16 doesn't have any room its just a passover node
roomToNode.set(162,"a17");
roomToNode.set("Commons","a17");
// a18 and a19 doesnt have any room its just a passover node
roomToNode.set(200,"a20");
roomToNode.set(205,"a21");
roomToNode.set(206,"a21");
roomToNode.set(216,"a21");
roomToNode.set(208,"a22");
roomToNode.set(215,"a22");
roomToNode.set(212,"a23");
// a24 doesn't have any room its just a passover node
roomToNode.set(230,"a25");
roomToNode.set(231,"a25");
roomToNode.set(232,"a25");
roomToNode.set(233,"a26");
roomToNode.set(234,"a26");
roomToNode.set(236,"a26");
roomToNode.set(235,"a26");
roomToNode.set(237,"a27");
roomToNode.set(238,"a27");
roomToNode.set(239,"a27");
// a28 doesn't have any room its just a passover node
// TODO: map a29 to end
roomToNode.set(165,"a30");
roomToNode.set(166,"a30");
roomToNode.set(168,"a30");
roomToNode.set(167,"a30");
roomToNode.set(163,"a30");
roomToNode.set(171,"a31");
roomToNode.set(176,"a32");
roomToNode.set(175,"a32");
roomToNode.set(001,"b0");
roomToNode.set(003,"b0");
roomToNode.set(004,"b0");
roomToNode.set(005,"b1");
roomToNode.set(006,"b1");
roomToNode.set(007,"b1");
roomToNode.set(008,"b1");
roomToNode.set(009,"b2");
roomToNode.set(010,"b2");
roomToNode.set(011,"b2");
roomToNode.set(012,"b2");
roomToNode.set(013,"b3");
roomToNode.set(014,"b3");
roomToNode.set(015,"b3");</script>
    <script>nodes.set("a0", [60,60]);
nodes.set("a1", [145,60]);
nodes.set("a2", [60,104]);
nodes.set("a3", [144,104]);
nodes.set("a4", [31,184]);
nodes.set("a5", [63,184]);
nodes.set("a6", [143,184]);
nodes.set("a7", [31,226]);
nodes.set("a8", [62,226]);
nodes.set("a9", [144,226]);
nodes.set("a10", [168,226]);
nodes.set("a11", [213,227]);
nodes.set("a12", [210,188]);
nodes.set("a13", [179,156]);
nodes.set("a14", [144,156]);
nodes.set("a15", [205,104]);
nodes.set("a16", [221,104]);
nodes.set("a17", [246,128]);
nodes.set("a18", [223,156]);
nodes.set("a19", [275,104]);
nodes.set("a20", [316,104]);
nodes.set("a21", [345,104]);
nodes.set("a22", [345,128]);
nodes.set("a23", [345,139]);
nodes.set("a24", [351,148]);
nodes.set("a25", [352,187]);
nodes.set("a26", [397,188]);
nodes.set("a27", [438,188]);
nodes.set("a28", [426,190]);
nodes.set("a29", [254,160]);
nodes.set("a30", [254,183]);
nodes.set("a31", [254,214]);
nodes.set("a32", [291,215]);
nodes.set("a33", [244,215]);
nodes.set("a34", [216,214]);
var NUMBER_OF_MAIN_FLOOR_NODES=nodes.size;
// The Pit & Downstairs
floorNodes.set("b0",[339,315]);
floorNodes.set("b1",[378,315]);
floorNodes.set("b2",[416,315]);
floorNodes.set("b3",[465,315]);
floorNodes.set("b4",[620,365]);
floorNodes.set("b5",[590,360]);
floorNodes.set("b6",[625,410]);
floorNodes.set("b7",[617,410]);
floorNodes.set("b8",[626,442]);
floorNodes.set("b9",[657,442]);
floorNodes.set("b10",[682,442]);
floorNodes.set("b11",[703,442]);
floorNodes.set("b12",[703,453]);</script>
    <script>neighbors.set("a0", ["a1","a2","b0"]);
neighbors.set("a1", ["a0","a3","b2"]);
neighbors.set("a2", ["a0","a3","a5"]);
neighbors.set("a3", ["a1","a2","a14","a15"]);
neighbors.set("a4", ["a5"]);
neighbors.set("a5", ["a2","a4","a6","a8"]);
neighbors.set("a6", ["a5","a9","a14"]);
neighbors.set("a7", ["a8"]);
neighbors.set("a8", ["a5","a7","a9"]);
neighbors.set("a9", ["a6","a8","a10"]);
neighbors.set("a10", ["a9","a11"]);
neighbors.set("a11", ["a10","a12","a34"]);
neighbors.set("a12", ["a11","a13","a34"]);
neighbors.set("a13", ["a12","a14","a18"]);
neighbors.set("a14", ["a3","a13","a6"]);
neighbors.set("a15", ["a3","a16"]);
neighbors.set("a16", ["a15","a17"]);
neighbors.set("a17", ["a16","a18","a19","a29"]);
neighbors.set("a18", ["a13","a17"]);
neighbors.set("a19", ["a17","a20"]);
neighbors.set("a20", ["a19","a21"]);
neighbors.set("a21", ["a20","a22"]);
neighbors.set("a22", ["a21","a23","b6"]);
neighbors.set("a23", ["a22","a24"]);
neighbors.set("a24", ["a23","a25"]);
neighbors.set("a25", ["a24","a26"]);
neighbors.set("a26", ["a25","a28"]);
neighbors.set("a27", ["a28"]);
neighbors.set("a28", ["a26","a27","b12"]);
neighbors.set("a29", ["a17","a30"]);
neighbors.set("a30", ["a29","a31"]);
neighbors.set("a31", ["a30","a32","a33"]);
neighbors.set("a32", ["a31"]);
neighbors.set("a33", ["a31","a34"]);
neighbors.set("a34", ["a33","a11","a12"]);
// ---------------------------------------------------
neighbors.set("b0", ["a0","b1"]);
neighbors.set("b1", ["b0","b2"]);
neighbors.set("b2", ["a1","b1","b3"]);
neighbors.set("b3", ["b2"]);
neighbors.set("b4",["b5","b7"]);
neighbors.set("b5",["b4"]);
neighbors.set("b6",["b7","b8","a22"]);
neighbors.set("b7",["b4","b6"]);
neighbors.set("b8",["b6","b9"]);
neighbors.set("b9",["b8","b10"]);
neighbors.set("b10",["b9","b11"]);
neighbors.set("b11",["b10","b12"]);
neighbors.set("b12",["b11","a28"]);</script>
    
    <script>class node {
  constructor(x,y,start=false,end=false,floor="a",canvasWidth,canvasHeight) {
    this.x=canvasWidth*x/757;
    this.y=canvasHeight*y/481;
    this.isStart=start;
    this.isGoal=end;
    this.connections=[];
    this.parent;
    this.gscore;
    this.floor=floor;
  }
  distTo(n) {
    // If two nodes are right on top of each other, return 0.1, an estimation of the length of the stairwell
    if(this.floor!=n.floor) {return 10;}
      
    // Otherwise just use pythagorean theorem
    return Math.sqrt(Math.pow(n.x-this.x,2)+Math.pow(n.y-this.y,2));
  }
  f_cost(end) {
    if(this.isStart) {return 0;}
    var gCost = end.distTo(this);
    var hCost = h_cost(this,0);
    
    return gCost+hCost;
  }
  equals(n) {
    if(this.x==n.x && this.y==n.y) {return true;}
    return false;
  }
}</script>
    <script>const mapp = document.getElementById("map");
function v(startNode, endNode) {
    // Clean the canvas for future drawing
    pen.clearRect(0,0,canvas.width,canvas.height);
    
    
    
    // Initialize the datas array which will store all nodes
    var datas = [];
    
    // Here I load the nodes into datas[], and set isStart and isGoal if they are.
    for(var i=0;i<NUMBER_OF_MAIN_FLOOR_NODES;i++) {
        // "nodes" is a map with the name of the node (a15 for example) as key and its coords as values.
        var coords=new node(nodes.get("a"+i)[0],nodes.get("a"+i)[1],false,false,"a",mapp.width,mapp.height);
        //drawNode(coords,i);  //<--- optionally draw the node to screen
    
        if(i==startNode.substring(1)&&startNode.charAt(0)=='a') {coords.isStart=true;var start =i;}
        if(i==endNode.substring(1)&&endNode.charAt(0)=='a') {coords.isGoal=true;var goal = i;}

        datas.push(coords);
    }
    // Load basement (The Pit) nodes
    for(var i=0;i<floorNodes.size;i++) {
        // "nodes" is a map with the name of the node (a15 for example) as key and its coords as values.
        var coords=new node(floorNodes.get("b"+i)[0],floorNodes.get("b"+i)[1],false,false,"b",mapp.width,mapp.height);
        //drawNode(coords,i);  //<--- optionally draw the node to screen
    
        if(i==startNode.substring(1)&&startNode.charAt(0)=='b') {coords.isStart=true;var start =i+NUMBER_OF_MAIN_FLOOR_NODES;}
        if(i==endNode.substring(1)&&endNode.charAt(0)=='b') {coords.isGoal=true;var goal = i+NUMBER_OF_MAIN_FLOOR_NODES;}

        datas.push(coords);
    }
    
    // Initialize all the neighbors. Having loaded nodes is great. Lets get them to know each other!
    
    // TODO: Make this loop load basement nodes
    
    for(var i=0;i<datas.length;i++) {
        // Grab neighbors from 'neighbors' map
        if(neighbors.has("a"+i)) {
            var neighbor=neighbors.get("a"+i);
        } else {
            
            var neighbor=neighbors.get("b"+(i-NUMBER_OF_MAIN_FLOOR_NODES));
        }
        
        for(var j=0;j<neighbor.length;j++) {
            // Add them to each nodes connections attribute
//            datas[i].connections.push(datas[neighbor[j].substring(1)]);
            var current=neighbor[j];
            if(current.charAt(0)=='a') {
                datas[i].connections.push(datas[neighbor[j].substring(1)]);
            } 
            else if(current.charAt(0)=='b') {
                
                datas[i].connections.push(datas[parseInt(neighbor[j].substring(1))+NUMBER_OF_MAIN_FLOOR_NODES]);
            }
        }
    }
            
            
        
                
            
        
        
    
    
    // Create open and closed arrays.
    //      *Open is for possible candidates to explore
    //      *Closed is for already visitied nodes
    var open = [];
    var closedd = [];
    
    // Add starting node to open. 
    open.push(datas[start]);
    
    // While loop. If it runs out of nodes in 'open' then it fails
    while(open.length!=0) {
        
        // Find smallest f cost in the open list and set it to currentNode
        var f_costs = [];
        for(var i=0;i<open.length;i++) {
                f_costs[i]=open[i].f_cost(datas[goal]);
        }
        var currentNode=open[getSmallestIndex(f_costs)];
        
        // Remove this node from the open list and add it to the closed list since it's now visited.
        //      *also, this .splice() caused me an issue that took a day to resolve. Why must I specify one?!
        open.splice(getSmallestIndex(f_costs),1);
        closedd.push(currentNode);
    
        
        // If it's the goal, log it and call raceToBottom.
        if(currentNode.isGoal) {
            console.log("Found goal!");
            // Race to bottom backtracks from the goal using the parents to draw the line.
            raceToBottom(currentNode);
            return;
        }
    
        // Now it's time to add the explored nodes neighbors to the open list
        for(var i=0;i<currentNode.connections.length;i++) {
            // n is the current neighbor that is (possibly) being added to open
            var n = currentNode.connections[i];
            
    
            // Calculate it's f cost. I can't use the node's built in f cost function because
            // the f cost function uses the h cost function with requires an initialized parent
            // But since this one hasn't been added to open yet, it doesn't have a parent. 
            // Thankfully, currentNode DOES have a parent because it's coming from the open list.
            var n_Cost = h_cost(currentNode,0)+n.distTo(currentNode)+n.distTo(datas[goal]);
    
            if(open.filter(function(e){return e.floor==n.floor&&e.x==n.x&&e.y==n.y&&e.f_cost(datas[goal])<=n_Cost;}).length>0) {
                //Skip if open list already has a node with this position and lower F cost
      
            }
            else if(closedd.filter(function(ee){return ee.floor==n.floor&&ee.x==n.x&&ee.y==n.y&&ee.f_cost(datas[goal])<=n_Cost;}).length>0) {
                //Skip if CLOSED list already had a node with this position and lower F cost
        

            } else {
                // Populate open list with new neighbors and set their parents to current node
                // Note how it's parent is being initialized, in addition to being how it draws the line,
                // it's also critical for the f cost calculation as seen in the n_Cost
                n.parent=currentNode;
                open.push(n);
        
            }
    
    
    
       
        }
    
  
    }
}</script>
    <script>console.log("hello");
params = new URLSearchParams(window.location.search);

function drawNode(n, index) {
  pen.fillStyle="rgb(100,0,0)";
  if(n.isStart) {
    pen.fillStyle="rgb(0,255,0)";
  }
  if(n.isGoal) {
    pen.fillStyle="rgb(255,0,0)";
  }
  pen.beginPath();
  pen.ellipse(n.x,n.y,4,4,0,0,Math.PI*2);
  pen.font="20px serif"
  pen.fillText(index,n.x+5,n.y);
  pen.fill();
}
function h_cost(n,sum) {
  if(n.isStart) {return sum;}
  return sum+h_cost(n.parent,n.distTo(n.parent));
}
var canvas = document.getElementById('canvas');
var pen = canvas.getContext('2d');

const width=760;
const height=475;
pen.strokeStyle="rgb(0,255,0)";
pen.lineWidth=5;
var datas = [];


startingLocation=params.get("start");
endingLocation=params.get("end");
// Initialize the index in datas that will later become the index for the start and goal nodes
var start=0;
var goal=0;
if(startingLocation!="Commons" && startingLocation!="Main Office") {
    startingLocation=Number(startingLocation);
}
if(endingLocation!="Commons" && endingLocation!="Main Office") {
    endingLocation=Number(endingLocation);
}
        function onWindowChange() {
            v(roomToNode.get(startingLocation),roomToNode.get(endingLocation));
        }
window.onresize=onWindowChange;
onWindowChange();
function mousePressed(e) {
    alert(e.clientX+","+e.clientY);
}


function getSmallestIndex(n) {
  var min=0;
  for(var i=0;i<n.length;i++) {
    if(n[i]<n[min]) {
      min=i;
    }
  }
  return min;
}
function raceToBottom(n) {
  if(n.isStart) {return n;}
  if(n.floor!=n.parent.floor) {return raceToBottom(n.parent);}
  pen.beginPath();
    //pen.setLineDash([10,10]);
  pen.moveTo(n.x,n.y);
  pen.lineTo(n.parent.x,n.parent.y);
  pen.stroke();
  return raceToBottom(n.parent);
}</script>
    
</html>
